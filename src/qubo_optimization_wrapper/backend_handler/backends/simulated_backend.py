from qubo_optimization_wrapper.backend_handler.backends.backend_interface import Backend
from neal import SimulatedAnnealingSampler
import dimod


class SimulatedBackend(Backend):
    def __init__(self):
        self._sampler = SimulatedAnnealingSampler()

    def sample(self, bqm: dimod.BinaryQuadraticModel, **params) -> dimod.SampleSet:
        """
        Ejecuta objeto bqm en el simulador SimulatedAnnealingSampler

        Parameters:
            bqm: The binary quadratic model to be sampled
            beta_range (tuple, optional) : A 2-tuple defining the beginning and end of the beta schedule, where beta is the inverse temperature. The schedule is interpolated within this range according to the value specified by beta_schedule_type. Default range is set based on the total bias associated with each node.
            num_reads (int, optional, default=len(initial_states) or 1) : Number of reads. Each read is generated by one run of the simulated annealing algorithm. If num_reads is not explicitly given, it is selected to match the number of initial states given. If initial states are not provided, only one read is performed.
            num_sweeps (int, optional, default=1000) : Number of sweeps or steps.
            beta_schedule_type (string, optional, default='geometric') : Beta schedule type, or how the beta values are interpolated between the given ‘beta_range’. Supported values are: linear, geometric.
            seed (int, optional) : Seed to use for the PRNG. Specifying a particular seed with a constant set of parameters produces identical results. If not provided, a random seed is chosen.
            interrupt_function (function, optional) : If provided, interrupt_function is called with no parameters between each sample of simulated annealing. If the function returns True, then simulated annealing will terminate and return with all of the samples and energies found so far.
            initial_states (samples-like, optional, default=None) : One or more samples, each defining an initial state for all the problem variables. Initial states are given one per read, but if fewer than num_reads initial states are defined, additional values are generated as specified by initial_states_generator. See func:.as_samples for a description of “samples-like”.
            initial_states_generator (str, 'none'/'tile'/'random', optional, default='random') : Defines the expansion of initial_states if fewer than num_reads are specified: ”none”:If the number of initial states specified is smaller than num_reads, raises ValueError. ”tile”:Reuses the specified initial states if fewer than num_reads or truncates if greater. ”random”:Expands the specified initial states with randomly generated states if fewer than num_reads or truncates if greater.

        Returns:
            dimod.SampleSet: Iterable of samples.
        """

        # Filtrar params que SA no usa
        sa_params = {k: v for k, v in params.items() if k in self._sampler.parameters}
        return self._sampler.sample(bqm, **sa_params)

    def get_properties(self) -> dict:
        "return: A dict containing any additional information about the sampler"
        return self._sampler.properties

    def get_parameters(self) -> dict:
        "returns: A dict where keys are the keyword parameters accepted by the sampler methods (allowed kwargs) and values are lists of SimulatedAnnealingSampler.properties relevant to each parameter."
        return self._sampler.parameters
